<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Характеристики станка</title>

    <!-- Сетевые подсказки -->
    <link rel="preconnect" href="https://docs.google.com" crossorigin>
    <link rel="dns-prefetch" href="https://docs.google.com">

    <style>
        :root {
            --card: #fff;
            --muted: #6b7280;
            --border: #e5e7eb;
            --bg: #f7f7f9;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background: var(--bg);
            color: #111827;
        }

        .wrap {
            max-width: 1100px;
            margin: 0 auto;
            padding: 16px;
        }

        h1 {
            margin: 0 0 .6rem;
            font-size: 1.4rem;
        }

        .muted {
            color: var(--muted);
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
        }

        .grid {
            display: grid;
            gap: 14px;
        }

        /* summary */
        .summary {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 8px 12px;
        }

        .summary div:nth-child(odd) {
            font-weight: 600;
            color: #374151;
        }

        /* table */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #f3f4f6;
            color: #374151;
            text-align: left;
            font-weight: 700;
            border-bottom: 1px solid var(--border);
            padding: 8px 10px;
        }

        tbody td {
            border-bottom: 1px solid #f1f5f9;
            padding: 8px 10px;
            vertical-align: top;
        }

        tbody tr:hover {
            background: rgba(37, 99, 235, .06);
        }

        /* alerts */
        .error {
            white-space: pre-wrap;
            background: #fff5f5;
            border: 1px solid #fbcfe8;
            color: #9b1c1c;
            padding: .6em;
            border-radius: 8px;
            display: none;
        }

        @media (max-width: 720px) {
            .summary {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1 id="title">Характеристики станка</h1>

        <div id="summary" class="card" style="margin-bottom:12px;"></div>

        <div class="card" style="margin-bottom:12px;">
            <table>
                <thead>
                    <tr>
                        <th style="width:45%">Параметр</th>
                        <th style="width:20%">Ед. изм.</th>
                        <th>Значение</th>
                    </tr>
                </thead>
                <tbody id="detailsBody"></tbody>
            </table>
        </div>

        <pre id="error" class="error"></pre>
    </div>

    <script>
        // --- Полифилл Promise.any (совместимо со старыми мобильными браузерами) ---
        (function () {
            if (typeof Promise.any === "function") return;

            function AggregateErrorPolyfill(errors, message) {
                const err = new Error(message || "All promises were rejected");
                err.name = "AggregateError";
                err.errors = errors;
                return err;
            }

            Promise.any = function (iterable) {
                return new Promise((resolve, reject) => {
                    const errors = [];
                    let pending = 0;
                    let hasAny = false;

                    for (const p of iterable) {
                        hasAny = true;
                        pending++;
                        Promise.resolve(p).then(resolve, (e) => {
                            errors.push(e);
                            if (--pending === 0) {
                                reject(AggregateErrorPolyfill(errors));
                            }
                        });
                    }
                    if (!hasAny) {
                         reject(AggregateErrorPolyfill([], "No promises were passed"));
                    }
                });
            };
        }());
        
        'use strict';

        /* ===== Конфиг листов ===== */
        const SPREADSHEET_ID = '1uLMv39-f9U2qKzAanPEHXPRjNezLlZJC';
        const GIDS = { lathe: '1008569495', milling: '361418967' };
        const sheetCSV = (sheetId, gid) => `/api/sheet?format=csv&sheetId=${encodeURIComponent(sheetId)}&gid=${encodeURIComponent(gid)}`;

        /* ===== Утилиты ===== */
        const $ = s => document.querySelector(s);
        const safeCell = (m, r, c) => (m[r] && m[r][c] !== undefined) ? m[r][c] : '';
        function showErr(msg) { const el = $('#error'); el.textContent = msg; el.style.display = 'block'; }
        function esc(s) { return String(s ?? '').replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' }[m])); }

        /* Надёжный CSV-парсер с поддержкой кавычек и запятых */
        function parseCSV(text) {
            const rows = []; let row = [], cur = '', q = false;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i], n = text[i + 1];
                if (q) {
                    if (ch === '"' && n === '"') { cur += '"'; i++; }
                    else if (ch === '"') { q = false; }
                    else { cur += ch; }
                } else {
                    if (ch === '"') q = true;
                    else if (ch === ',') { row.push(cur); cur = ''; }
                    else if (ch === '\n') { row.push(cur); rows.push(row); row = []; cur = ''; }
                    else if (ch === '\r') { /* skip */ }
                    else { cur += ch; }
                }
            }
            if (cur.length || row.length) { row.push(cur); rows.push(row); }
            return rows.filter(r => r.length && !(r.length === 1 && r[0] === ''));
        }

        /* ===== Быстрая загрузка CSV: кэш + параллельная гонка ===== */
        function showStaleNotice(msg = 'Показаны данные из кэша — сеть недоступна.') {
            const id = 'staleNotice';
            let el = document.getElementById(id);
            if (!el) {
                el = document.createElement('div'); el.id = id;
                el.style.cssText = 'margin:8px 0;padding:8px 10px;border:1px dashed #f59e0b;background:#fffaf0;color:#92400e;border-radius:6px;';
                const title = $('#title') || document.body; title.parentNode.insertBefore(el, title.nextSibling);
            }
            el.textContent = msg;
        }

        const CACHE_TTL_MS = 5 * 60 * 1000;
        function pickTimeoutMs() {
            const et = (navigator.connection && navigator.connection.effectiveType) || '';
            if (et.includes('2g')) return 60000; // 60s
            if (et.includes('3g')) return 35000; // 35s
            return 20000; // 20s
        }
        async function fetchSheetCSVRace(tab, sheetId, gid) {
            const sources = [];

            // ====== (A) MIRROR — только если у вас реально есть /data/<tab>.csv ======
            const mirrorUrl = `/data/${tab}.csv`;
            const mirrorTimeout = 1500; // 1.5s максимум
            sources.push(fetchWithTimeout(mirrorUrl, mirrorTimeout, "no-store"));

            // ====== (B) Proxy-функция ======
            const proxyUrl = `/api/sheet?format=csv&sheetId=${encodeURIComponent(sheetId)}&gid=${encodeURIComponent(gid)}`;
            sources.push(lazy(200, () => fetchWithTimeout(proxyUrl, 12000, "default")));

            // ====== (C) Published to web ======
            const publishBase = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSSoiSE1ZmtEo4JQOEIHiJWWTjiG_cV1s7rtcjuUYmbafvuDV1k1_53Q6p-L0f8Qg/pub";
            const publishedUrl = `${publishBase}?gid=${encodeURIComponent(gid)}&single=true&output=csv`;
            sources.push(lazy(500, () => fetchWithTimeout(publishedUrl, 12000, "default")));

            // ====== (D) Прямой export ======
            const directUrl = `https://docs.google.com/spreadsheets/d/${encodeURIComponent(sheetId)}/export?format=csv&gid=${encodeURIComponent(gid)}`;
            sources.push(lazy(900, () => fetchWithTimeout(directUrl, 12000, "default")));

            // ——— реализация гонки с отменой «проигравших» ———
            const ctrls = [];
            function fetchWithTimeout(url, ms, cacheMode) {
                const ctrl = new AbortController();
                ctrls.push(ctrl);
                const t = setTimeout(() => ctrl.abort(), ms);
                return fetch(url, { cache: cacheMode, signal: ctrl.signal }).then(async r => {
                    clearTimeout(t);
                    if (!r.ok) throw new Error(`${url} -> HTTP ${r.status}`);
                    // 404 на mirror — сразу бросаем, чтобы не висел
                    if (r.status === 404) throw new Error(`${url} -> 404`);
                    return r.text();
                });
            }
            function lazy(delay, fn) {
                return new Promise((res, rej) => setTimeout(() => fn().then(res, rej), delay));
            }

            try {
                const csv = await Promise.any(sources);
                // победитель найден — гасим остальных
                ctrls.forEach(c => { try { c.abort(); } catch { } });
                return csv;
            } catch (agg) {
                const errs = agg?.errors || [agg];
                throw new Error("All sources failed: " + errs.map(e => e?.message || String(e)).join("; "));
            }
        }

        /* ===== Поиск нужной колонки по id модели ===== */
        function sanitizeId(s) { return String(s || '').toLowerCase().trim().replace(/\s+/g, ' '); }
        function findColumnByModel(matrix, wantId) {
            const target = sanitizeId(wantId);
            const cols = matrix[0]?.length || 0; if (!cols) return -1;
            // точное совпадение по строке модели (row index 2)
            for (let j = 3; j < cols; j++) {
                const name = sanitizeId(safeCell(matrix, 2, j));
                if (name && name === target) return j;
            }
            // более мягкий поиск (без пробелов/дефисов)
            const soft = target.replace(/[\s\-\u00A0]/g, '');
            for (let j = 3; j < cols; j++) {
                const name = sanitizeId(safeCell(matrix, 2, j)).replace(/[\s\-\u00A0]/g, '');
                if (name && name === soft) return j;
            }
            return -1;
        }

        /* ===== Рендер ===== */
        function renderSummary(matrix, col) {
            const type = String(safeCell(matrix, 0, col)).trim();
            const brand = String(safeCell(matrix, 1, col)).trim();
            const model = String(safeCell(matrix, 2, col)).trim();

            $('#title').textContent = model ? `Модель ${model}` : 'Характеристики станка';
            $('#summary').innerHTML = `
    <div class="summary">
      <div>Тип станка</div><div>${esc(type) || '<span class="muted">—</span>'}</div>
      <div>Производитель</div><div>${esc(brand) || '<span class="muted">—</span>'}</div>
      <div>Модель</div><div>${esc(model) || '<span class="muted">—</span>'}</div>
    </div>`;
        }

        function getLastUsefulRow(m, col) {
            for (let r = m.length - 1; r >= 3; r--) {
                const p = String(safeCell(m, r, 1)).trim();
                const u = String(safeCell(m, r, 2)).trim();
                const v = String(safeCell(m, r, col)).trim();
                if (p || u || v) return r;
            }
            return 3;
        }

        function isJunkHeader(label) {
            const t = String(label || '').trim().toLowerCase();
            return t === 'параметр' || t === 'значение' || t === 'ед. изм.' || t === 'ед.изм.';
        }

        function hasValue(v) {
            const s = String(v ?? '').replace(/\u00A0/g, ' ').trim();
            if (!s) return false;                 // пусто
            if (/^[-–—]+$/.test(s)) return false; // одни тире
            if (/^(нет|n\/?a|na)$/i.test(s)) return false; // “нет/NA”
            return true;
        }

       function renderParams(matrix, col) {
            const last = getLastUsefulRow(matrix, col);
            let html = '';
            for (let r = 3; r <= last; r++) {
                const param = String(safeCell(matrix, r, 1)).trim(); // B
                const unit = String(safeCell(matrix, r, 2)).trim(); // C
                const val = String(safeCell(matrix, r, col)).trim(); // значение

                // пропускаем “шапки” и пустые/псевдопустые значения
                if (isJunkHeader(param) || isJunkHeader(unit) || isJunkHeader(val)) continue;
                if (!hasValue(val)) continue; // <<< ключевая строка — не выводим пустые значения

                const p = hasValue(param) ? esc(param) : '<span class="muted">—</span>';
                const u = hasValue(unit) ? esc(unit) : '<span class="muted">—</span>';
                const v = esc(val);

                html += `<tr><td>${p}</td><td>${u}</td><td>${v}</td></tr>`;
            }
            $('#detailsBody').innerHTML =
                html || `<tr><td colspan="3" class="muted">Данные отсутствуют</td></tr>`;
        }

        /* ===== Основной поток ===== */
        async function main() {
            const qs = new URLSearchParams(location.search);
            const id = (qs.get('id') ? decodeURIComponent(qs.get('id')) : '').toLowerCase().trim();
            const tab = (qs.get('tab') ? qs.get('tab') : 'lathe').toLowerCase();
            const gid = GIDS[tab] || GIDS.lathe;
            if (!id) { throw new Error('Модель не указана (id)'); }

            const csv = await fetchSheetCSVRace(tab, SPREADSHEET_ID, gid);
                        const matrix = parseCSV(csv);
            const col = findColumnByModel(matrix, id);
            if (col === -1) { throw new Error('Модель не найдена по id: ' + id); }

            renderSummary(matrix, col);
            renderParams(matrix, col);
        }

        // НЕ блокируем отрисовку страницы
        window.addEventListener('DOMContentLoaded', () => {
            const kick = () => main().catch(err => showErr(
                'Не удалось загрузить данные (CSV).\nПроверьте доступ к листу и gid.\n\n' + (err && err.message ? err.message : String(err))
            ));

            if ('requestIdleCallback' in window) {
                requestIdleCallback(kick, { timeout: 2000 });
            } else {
                setTimeout(kick, 0);
            }
        });
    </script>
</body>

</html>